using System;
using System.Linq;
using InsideWordResource;
using System.Collections.Generic;
using System.Data.Objects;
using System.Data.Objects.DataClasses;
using System.Web;
using System.Text;

namespace InsideWordProvider
{
    [Serializable]
    public class ProviderArticle : Provider
    {
    #region Public and Attribute Region
        protected const int MAX_AUTO_BLURB_LENGTH = 200;
        protected Article _entityArticle;
        protected ChangeList<long> _pendingPhotoIds;
        protected ChangeList<long> _pendingCategoryIds;
        protected ChangeList<long> _pendingAlternateCategoryIds;
        protected bool _blurbHasChanged;
        protected bool _forceRefresh;
        protected string _tempText;

        public ProviderArticle() : base() { }
        public ProviderArticle(long id) : base(id) { }

        public DateTime CreateDate
        {
            get { return _entityArticle.CreateDate; }
            set { _entityArticle.CreateDate = value; }
        }

        public DateTime EditDate
        {
            get { return _entityArticle.EditDate; }
            set { _entityArticle.EditDate = value; }
        }

        public int ViewCount
        {
            get { return _entityArticle.ReadCount; }
            set { _entityArticle.ReadCount = value; }
        }

        public string Title
        {
            get { return _entityArticle.Title; }
            set { _entityArticle.Title = value; }
        }

        public long? MemberId
        {
            get { return _entityArticle.MemberId; }
            set { _entityArticle.MemberId = value; }
        }

        public ProviderMember Author
        {
            get
            {
                ProviderMember author = null;
                if (_entityArticle.MemberId.HasValue)
                {
                    author = new ProviderMember(_entityArticle.Member);
                }
                return author;
            }
        }

        public bool IgnoreFlags
        {
            get { return _entityArticle.IgnoreFlags; }
            set { _entityArticle.IgnoreFlags = value; }
        }

        public bool IsPublished
        {
            get { return _entityArticle.IsPublished; }
            set { _entityArticle.IsPublished = value; }
        }

        public string Blurb
        {
            get
            {
                return _entityArticle.Blurb;
            }
            set
            {
                _blurbHasChanged = true;
                _entityArticle.BlurbIsAutoGen = string.IsNullOrWhiteSpace(value);
                _entityArticle.Blurb = value;
            }
        }

        public bool BlurbIsAutoGenerated
        {
            get
            {
                return _entityArticle.BlurbIsAutoGen;
            }
        }

        public string RawText
        {
            get
            {
                string returnValue = null;
                if (!string.IsNullOrEmpty(_tempText))
                {
                    returnValue = _tempText;
                }
                else
                {
                    returnValue = _entityArticle.ArticleTexts
                                           .Where(articleText => articleText.TextType == (int)TextType.raw)
                                           .Select(articleText => articleText.Text)
                                           .FirstOrDefault();
                }
                return returnValue;
            }
            set
            {
                _tempText = value;
            }
        }

        public string ParsedText
        {
            get
            {
                int parsedText = (int)TextType.parsed;
                return _entityArticle.ArticleTexts
                                        .Where(articleText => articleText.TextType == parsedText)
                                        .Select(articleText => articleText.Text)
                                        .FirstOrDefault();
            }
        }

        /// <summary>
        /// All photos (blurb and article)
        /// </summary>
        public List<ProviderPhotoRecord> Photos
        {
            get
            {
                return _entityArticle.Photos.ToList().ConvertAll(ProviderPhotoRecord._converterEntityToProvider);
            }
        }

        /// <summary>
        /// Only full size article photos
        /// </summary>
        public List<ProviderPhotoRecord> ArticlePhotos
        {
            get
            {
                return ProviderPhotoRecord.LoadArticlePhotosByArticleId(_entityArticle.Id);
            }
        }

        /// <summary>
        /// Photo Ids for all photos (article and blurb)
        /// </summary>
        public List<long> PhotoIds
        {
            get
            {
                return _entityArticle.Photos
                                     .Select(photo => photo.Id)
                                     .ToList();
            }
        }

        public void AddPhoto(long photoId)
        {
            _pendingPhotoIds.Add(photoId);
        }

        public void RemovePhoto(long photoId)
        {
            _pendingPhotoIds.Remove(photoId);
        }

        public void RemoveAllPhotos()
        {
            foreach (long photoId in this.PhotoIds)
            {
                this.RemovePhoto(photoId);
            }
        }

        public List<long> CategoryIds
        {
            get { return _entityArticle.Categories.Select(category => category.Id).ToList(); }
        }

        public List<string> CategoryNames
        {
            get { return _entityArticle.Categories.Select(category => category.Title).ToList(); }
        }

        public void AddCategory(long categoryId)
        {
            _pendingCategoryIds.Add(categoryId);
        }

        public void RemoveCategory(long categoryId)
        {
            _pendingCategoryIds.Remove(categoryId);
        }

        public void RemoveAllCategories()
        {
            foreach (long categoryId in this.CategoryIds)
            {
                this.RemoveCategory(categoryId);
            }
        }

        public List<ProviderAlternateCategoryId> AlternateCategoryList
        {
            get
            {
                return _entityArticle.AlternateCategoryIds
                                      .ToList()
                                      .ConvertAll(ProviderAlternateCategoryId._converterEntityToProvider);
            }
        }

        public List<long> AlternateCategoryIds
        {
            get { return _entityArticle.AlternateCategoryIds.Select(altCat => altCat.Id).ToList(); }
        }

        public void AddAlternateCategory(long altCategoryId)
        {
            _pendingAlternateCategoryIds.Add(altCategoryId);
        }

        public void RemoveAlternateCategory(long altCategoryId)
        {
            _pendingAlternateCategoryIds.Remove(altCategoryId);
        }

        public void RemoveAllAlternateCategories()
        {
            foreach (long altCategoryId in this.AlternateCategoryIds)
            {
                this.RemoveAlternateCategory(altCategoryId);
            }
        }

        public bool HasBlurbThumbnail
        {
            get { return _entityArticle.Photos
                                       .Any(photo => photo.Thumbnails
                                                          .Any(thumbnailPhoto => thumbnailPhoto.ImageType == (int)ProviderPhotoRecord.ImageTypeEnum.BlurbThumbnail)); }
        }

        // Fetches a random blurb photo or null if none exist
        public ProviderPhotoRecord RandomBlurbPhoto
        {
            get
            {
                Random rand = new Random((int)DateTime.UtcNow.Ticks);
                List<Photo> entityPhotoList = _entityArticle.Photos
                                                            .SelectMany(photo => photo.Thumbnails)
                                                            .Where(thumbnailPhoto => thumbnailPhoto.ImageType == (int)ProviderPhotoRecord.ImageTypeEnum.BlurbThumbnail).ToList();
                int total = entityPhotoList.Count;
                return new ProviderPhotoRecord(entityPhotoList[rand.Next() % total]);
            }
        }

        public int CountFlags
        {
            get { return _entityArticle.ArticleVotes.Where(aVote => aVote.IsFlag).Count(); }
        }

        public int CountConversations
        {
            get { return _entityArticle.Conversations.Count(); }
        }

        public int CountComments
        {
            get
            {
                int intCommentSum = (int)ProviderArticleScore.ScoreTypeEnum.CommentSum;
                return (int)_entityArticle.ArticleScores
                                          .Where(score => score.ScoreType == intCommentSum)
                                          .Select(score => score.Score)
                                          .FirstOrDefault();
            }
        }

        public int CountVotes
        {
            get
            {
                int intSparrowScore = (int)ProviderArticleScore.ScoreTypeEnum.PublicVoteSum;
                return (int)_entityArticle.ArticleScores
                                          .Where(score => score.ScoreType == intSparrowScore)
                                          .Select(score => score.Score)
                                          .FirstOrDefault();
            }
        }

        public double Score
        {
            get
            {
                int intSparrowScore = (int)ProviderArticleScore.ScoreTypeEnum.SparrowRank;
                return _entityArticle.ArticleScores
                                    .Where(score => score.ScoreType == intSparrowScore)
                                    .Select(score => score.Score)
                                    .FirstOrDefault();
            }
        }

        public List<ProviderConversation> Conversations
        {
            get { return ProviderConversation.LoadByArticleId(Id.Value); }
        }

        /// <summary>
        ///  Retrieve a list of headlines for articles that share any of the same categories as the current article.
        /// </summary>
        /// <param name="max">sets the max number of articles returned</param>
        /// <returns>List of ProviderArticle</returns>
        public Dictionary<long, string> RelatedHeadlinesByCategory(int max=-1)
        {
            long articleId = Id.Value;
            return DbCtx.Instance.Articles
                                      .Where(article => CategoryIds.Intersect(article.Categories.Select(category => category.Id))
                                                                   .Count() > 0 &&
                                                        article.Id != articleId &&
                                                        article.IsPublished &&
                                                        !article.IsHidden)
                                      .OrderByDescending(article => article.EditDate)
                                      .Take(max)
                                      .Select(anArticle => new { anArticle.Id, anArticle.Title })
                                      .ToDictionary(aPair => aPair.Id, aPair => aPair.Title);
        }

        /// <summary>
        /// get list of articles by the same author as the author of this article provider object
        /// </summary>
        /// <param name="max">sets the max number of articles returned</param>
        /// <returns>List<ProviderArticle></returns>
        public Dictionary<long, string> RelatedHeadlinesByAuthor(int max=-1)
        {
            long articleId = Id.Value;
            return DbCtx.Instance.Articles
                                      .Where(article => article.MemberId == _entityArticle.MemberId &&
                                                        article.Id != articleId &&
                                                        article.IsPublished &&
                                                        !article.IsHidden)
                                      .OrderByDescending(article => article.EditDate)
                                      .Take(max)
                                      .Select(anArticle => new { anArticle.Id, anArticle.Title })
                                      .ToDictionary(aPair => aPair.Id, aPair => aPair.Title);
        }

        public bool IsHidden
        {
            get { return _entityArticle.IsHidden; }
            set { _entityArticle.IsHidden = value; }
        }

        static protected Func<InsideWordEntities, long, Article> _loadByArticleId = null;
        override public bool Load(long articleId)
        {
            if (_loadByArticleId == null)
            {
                // compile this query
                _loadByArticleId = CompiledQuery.Compile<InsideWordEntities, long, Article>(
                    (ctx, anArticleId) => ctx.Articles
                                            .Include("ArticleTexts")
                                            .Include("Member.AlternateMemberIds")
                                            .Include("Photos.Thumbnails")
                                            .Include("ArticleScores")
                                            .Where(anArticle => anArticle.Id == anArticleId)
                                            .FirstOrDefault()
                );
            }

            Article entityArticle = _loadByArticleId.Invoke(DbCtx.Instance, articleId);
            return Load(entityArticle);
        }

        public void ForceRefresh()
        {
            _forceRefresh = true;
            Save();
            _forceRefresh = false;
        }

        override public void Save()
        {
            this.SaveTitle();
            this.SaveBlurb();

            if(IsNew)
            {
                // if this is new we need to save before we create the relationships
                base.Save();
            }
            this.SaveText();
            this.SavePhotoRelationships();
            this.SaveCategoryRelationships();

            base.Save();
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder(this.GetType().Name);
            sb.Append("\n\tId =\t" + _entityArticle.Id);
            sb.Append("\n\tSystemCreateDate =\t" + _entityArticle.SystemCreateDate);
            sb.Append("\n\tSystemEditDate =\t" + _entityArticle.SystemEditDate);
            sb.Append("\n\tCreateDate =\t" + _entityArticle.CreateDate);
            sb.Append("\n\tEditDate =\t" + _entityArticle.EditDate);
            sb.Append("\n\tIsHidden =\t" + _entityArticle.IsHidden);
            sb.Append("\n\tTitle =\t" + _entityArticle.Title);
            sb.Append("\n\tBlurb =\t" + _entityArticle.Blurb);
            sb.Append("\n\tReadCount =\t" + _entityArticle.ReadCount);
            sb.Append("\n\tIgnoreFlags =\t" + _entityArticle.IgnoreFlags);
            sb.Append("\n\tIsPublished =\t" + _entityArticle.IsPublished);
            sb.Append("\n\tBlurbIsAutoGen =\t" + _entityArticle.BlurbIsAutoGen);
            sb.Append("\n");

            return sb.ToString();
        }

        /* TODO: revisit all copy functions
        override public bool Copy(Provider untyped)
        {
            //Never copy over the id, otherwise we would be creating 
            //a pseudo-reference copy, which we don't want.
            ProviderArticle aArticle  = (ProviderArticle)untyped;
            _entityObject             = _entityArticle;
            _entityArticle.CreateDate = aArticle._entityArticle.CreateDate;
            _entityArticle.EditDate   = aArticle._entityArticle.EditDate;
            _entityArticle.IsHidden   = aArticle._entityArticle.IsHidden;
            _entityArticle.Text       = aArticle._entityArticle.Text;
            _entityArticle.Title   = aArticle._entityArticle.Title;
            _entityArticle.Blurb      = aArticle._entityArticle.Blurb;
            _entityArticle.IgnoreFlags = aArticle._entityArticle.IgnoreFlags;
            _entityArticle.IsPublished = aArticle._entityArticle.IsPublished;
            _entityArticle.BlurbIsAutoGen = aArticle._entityArticle.BlurbIsAutoGen;
            _blurbHasChanged = aArticle._blurbHasChanged;
            _textHasChanged = aArticle._textHasChanged;
            
            _pendingPhotoIds.Copy(aArticle._pendingPhotoIds);
            _pendingCategoryIds.Copy(aArticle._pendingCategoryIds);
            return true;
        }
        */
    #endregion
        //=========================================================
        // PRIVATE FUNCTIONS
        //=========================================================
    #region Private region
        protected ProviderArticle(Article anArticle) : base(anArticle) { }

        protected override IInsideWordEntity UnderlyingEntity
        {
            get { return _entityArticle; }
            set { _entityArticle = (Article)value; }
        }

        protected override void ClassClear()
        {
            base.ClassClear();
            _pendingPhotoIds = new ChangeList<long>();
            _pendingCategoryIds = new ChangeList<long>();
            _pendingAlternateCategoryIds = new ChangeList<long>();
            _blurbHasChanged = false;
            _tempText = null;
            _forceRefresh = false;
        }

        override protected void EntityClear()
        {
            _entityArticle = new Article();
            _entityArticle.Id = -1;
            _entityArticle.SystemCreateDate = new DateTime();
            _entityArticle.SystemEditDate = new DateTime();
            _entityArticle.CreateDate = new DateTime();
            _entityArticle.EditDate = new DateTime();
            _entityArticle.IsHidden = false;
            _entityArticle.Title = String.Empty;
            _entityArticle.Blurb = String.Empty;
            _entityArticle.ReadCount = 0;
            _entityArticle.IgnoreFlags = false;
            _entityArticle.IsPublished = false;
            _entityArticle.BlurbIsAutoGen = true;
        }

        protected void SaveTitle()
        {
            string tempTitle = HtmlParser.HtmlFree(_entityArticle.Title);
            tempTitle = HttpUtility.HtmlDecode(tempTitle);
            _entityArticle.Title = IWStringUtility.TruncateClean(tempTitle, TitleSize);
        }

        protected void SaveBlurb()
        {
            // Clean up the blurb of any unwanted html
            if(_blurbHasChanged || _forceRefresh)
            {
                if (!_entityArticle.BlurbIsAutoGen && !string.IsNullOrEmpty(_entityArticle.Blurb))
                {
                    string blurb = HtmlParser.HtmlFree(_entityArticle.Blurb);
                    blurb = IWStringUtility.TruncateClean(blurb, BlurbSize);
                    _entityArticle.Blurb = HtmlParser.HtmlFree(_entityArticle.Blurb);
                }
                else if (!string.IsNullOrEmpty(RawText))
                {
                    // auto generate blurb
                    HtmlParser htmlDoc = new HtmlParser(RawText);
                    string blurb = htmlDoc.HtmlFree();
                    blurb = IWStringUtility.TruncateClean(blurb, BlurbSize);
                    _entityArticle.Blurb = blurb;
                    _entityArticle.BlurbIsAutoGen = true;

                    // we've saved the changes so clear the changed bool
                    _blurbHasChanged = false;
                }
            }
        }

        protected void SaveText()
        {
            if (!string.IsNullOrEmpty(_tempText) || _forceRefresh)
            {
                ArticleText rawArticleText = LoadOrCreateArticleText((int)TextType.raw);
                ArticleText parsedArticleText = LoadOrCreateArticleText((int)TextType.parsed);
                string text = RawText;

                // If the RawText was null then try a recovery by using the parsed text
                text = text ?? parsedArticleText.Text;

                // If the text is still null then set it to blank
                text = text ?? "";

                HtmlParser htmlDoc = new HtmlParser(text);
                rawArticleText.Text = text;
                string injectionFreeHtml = htmlDoc.InjectionHtmlFree();
                parsedArticleText.Text = HtmlParser.EncloseUriLink(injectionFreeHtml);
                //We've saved the text so clear the temp variables
                _tempText = null;
            }
        }

        protected void SavePhotoRelationships()
        {
            //Handle the pending photo ids
            foreach (long photoId in _pendingPhotoIds.AddList)
            {
                // don't add the photo if it already exists
                if (_entityArticle.Photos.Where(aPhoto => aPhoto.Id == photoId).ToList().Count == 0)
                {
                    Photo aPhoto = DbCtx.Instance.Photos.Where(photo => photo.Id == photoId).Single();
                    _entityArticle.Photos.Add(aPhoto);
                    aPhoto.Articles.Add(_entityArticle);//don't forget the relationship to the photo or else it's one way
                }
            }

            foreach (long photoId in _pendingPhotoIds.RemoveList)
            {
                Photo aPhoto = _entityArticle.Photos.Where(photo => photo.Id == photoId).SingleOrDefault();
                if (aPhoto != null)
                {
                    _entityArticle.Photos.Remove(aPhoto);
                    aPhoto.Articles.Remove(_entityArticle);//don't forget the relationship to the photo or else it's one way
                }
            }
            _pendingPhotoIds.Clear();
        }

        protected void SaveCategoryRelationships()
        {
            // FIRST handle the pending alternate category ids
            foreach (long alternateCategoryId in _pendingAlternateCategoryIds.AddList)
            {
                // don't add the category if it already exists
                if (!_entityArticle.AlternateCategoryIds.Any(altCat => altCat.Id == alternateCategoryId))
                {
                    AlternateCategoryId alternateCategory = DbCtx.Instance.AlternateCategoryIds.Where(altCat => altCat.Id == alternateCategoryId).Single();
                    _entityArticle.AlternateCategoryIds.Add(alternateCategory);
                    alternateCategory.Articles.Add(_entityArticle);//don't forget the relationship to the category or else it's one way
                }
            }

            foreach (long alternateCategoryId in _pendingAlternateCategoryIds.RemoveList)
            {
                AlternateCategoryId alternateCategory = _entityArticle.AlternateCategoryIds.Where(altCat => altCat.Id == alternateCategoryId).SingleOrDefault();
                if (alternateCategory != null)
                {
                    _entityArticle.AlternateCategoryIds.Remove(alternateCategory);
                    alternateCategory.Articles.Remove(_entityArticle);//don't forget the relationship to the category or else it's one way
                }
            }
            _pendingAlternateCategoryIds.Clear();
            
            List<ProviderAlternateCategoryId> altCatList = this.AlternateCategoryList;
            if (altCatList.Count > 0 && altCatList.Any(altCatId => altCatId.CategoryId.HasValue))
            {
                // If there are any alternate categories then this overrides all other categories
                RemoveAllCategories();
                foreach (ProviderAlternateCategoryId altCatId in altCatList)
                {
                    if (altCatId.CategoryId.HasValue)
                    {
                        this.AddCategory(altCatId.CategoryId.Value);
                    }
                }
            }

            //Handle the pending category ids
            foreach (long categoryId in _pendingCategoryIds.AddList)
            {
                // don't add the category if it already exists
                if (!_entityArticle.Categories.Any(category => category.Id == categoryId))
                {
                    Category aCategory = DbCtx.Instance.Categories.Where(category => category.Id == categoryId).Single();
                    _entityArticle.Categories.Add(aCategory);
                    aCategory.Articles.Add(_entityArticle);//don't forget the relationship to the category or else it's one way
                }
            }

            foreach (long categoryId in _pendingCategoryIds.RemoveList)
            {
                Category aCategory = _entityArticle.Categories.Where(category => category.Id == categoryId).SingleOrDefault();
                if (aCategory != null)
                {
                    _entityArticle.Categories.Remove(aCategory);
                    aCategory.Articles.Remove(_entityArticle);//don't forget the relationship to the category or else it's one way
                }
            }
            _pendingCategoryIds.Clear();
        }

        protected ArticleText LoadOrCreateArticleText(int selectTextType)
        {
            ArticleText anArticleText = _entityArticle.ArticleTexts
                                                        .Where(articleText => articleText.TextType == selectTextType)
                                                        .FirstOrDefault();
            if (anArticleText == null)
            {
                anArticleText = new ArticleText();
                anArticleText.ArticleId = Id.Value;
                anArticleText.TextType = selectTextType;
                anArticleText.Version = 1;
                _entityArticle.ArticleTexts.Add(anArticleText);
            }

            return anArticleText;
        }
    #endregion
        //=========================================================
        // STATIC FUNCTIONS
        //=========================================================
    #region Static region
        public const int TitleSize = 65;
        public const int IdDigitSize = 18;
        public const int BlurbSize = 256;
        public const int ArticleBodySize = 32768;

        static protected Converter<Article, ProviderArticle> _converterEntityToProvider = new Converter<Article, ProviderArticle>(_EntityToProvider);
        static protected ProviderArticle _EntityToProvider(Article articleEntity)
        {
            return new ProviderArticle(articleEntity);
        }

        static public List<ProviderArticle> LoadNewestBy(int skipAmount, int takeAmount, bool? isHidden = null, bool? isPublished = null)
        {
            return DbCtx.Instance.Articles
                                      .Where(article => (isHidden == null || article.IsHidden == isHidden) &&
                                                        (isPublished == null || article.IsPublished == isPublished)
                                            )
                                      .OrderByDescending(article => article.SystemCreateDate)
                                      .Skip(skipAmount)
                                      .Take(takeAmount)
                                      .ToList()
                                      .ConvertAll(_converterEntityToProvider);
        }

        static Func<InsideWordEntities, string, int, int, IQueryable<Article>> _loadRankedBlurbBy = null;
        static public List<ProviderArticle> LoadRankedBlurbBy(ProviderCategory aCategory, int skipAmount, int takeAmount)
        {
            if (_loadRankedBlurbBy == null)
            {
                // compile this query
                int sparrowScoreType = (int)ProviderArticleScore.ScoreTypeEnum.SparrowRank;
                _loadRankedBlurbBy = CompiledQuery.Compile<InsideWordEntities, string, int, int, IQueryable<Article>>(
                    (ctx, categoryPath, skip, take) => ctx.Articles
                                    .Include("Member.AlternateMemberIds")
                                    .Include("Photos.Thumbnails")
                                    .Include("ArticleScores")
                                    .Where(article => article.Categories.Any(category => category.FullPath.StartsWith(categoryPath))
                                                    && !article.IsHidden
                                                    && article.IsPublished)
                                    .OrderByDescending(article => article.ArticleScores
                                                                         .Where(aScore => aScore.ScoreType == sparrowScoreType)
                                                                         .FirstOrDefault()
                                                                         .Score)
                                    .Skip(skip)
                                    .Take(take)
                );
            }
            
            //Checking the article's categories against the the FUllPath will ensure that we include the subcategories
            List<ProviderArticle> articleList = _loadRankedBlurbBy.Invoke(DbCtx.Instance, aCategory.FullPath, skipAmount, takeAmount)
                                                                   .ToList()
                                                                   .ConvertAll(_converterEntityToProvider);
            return articleList;
        }

        static Func<InsideWordEntities, long, int, int, bool?, bool?, IQueryable<Article>> _loadNewestBy = null;
        static public List<ProviderArticle> LoadNewestBy(ProviderMember aMember, int skipAmount, int takeAmount, bool? isHidden = null, bool? isPublished = null)
        {
            if (_loadNewestBy == null)
            {
                // compile this query
                _loadNewestBy = CompiledQuery.Compile<InsideWordEntities, long, int, int, bool?, bool?, IQueryable<Article>>(
                    (ctx, memberId, skip, take, hidden, published) => ctx.Articles
                                    .Include("Member.AlternateMemberIds")
                                    .Include("Photos.Thumbnails")
                                    .Include("ArticleScores")
                                    .Include("ArticleTexts")
                                    .Where(article => (article.MemberId != null && article.MemberId == memberId) &&
                                                      (hidden == null || article.IsHidden == hidden) &&
                                                      (published == null || article.IsPublished == published)
                                          )
                                    .OrderByDescending(article => article.SystemCreateDate)
                                    .Skip(skip)
                                    .Take(take)
                );
            }

            //Checking the article's categories against the the FUllPath will ensure that we include the subcategories
            List<ProviderArticle> articleList = _loadNewestBy.Invoke(DbCtx.Instance, aMember.Id.Value, skipAmount, takeAmount, isHidden, isPublished)
                                                                   .ToList()
                                                                   .ConvertAll(_converterEntityToProvider);
            return articleList;
        }

        static public List<ProviderArticle> LoadBy(DateTime aDateTime)
        {
            return DbCtx.Instance.Articles.Where(anArticle => aDateTime < anArticle.SystemEditDate)
                                               .ToList()
                                               .ConvertAll(_converterEntityToProvider);
        }

        /// <summary>
        /// Returns a list of all articles from a given member
        /// </summary>
        /// <param name="memberId">id of the member whose articles we wish to retrieve</param>
        /// <param name="isPublished">If set to null then retrieve all articles. If set to true then only published articles. If set to false then only non-published articles.</param>
        /// <param name="isHidden">If set to null then retrieve all articles. If set to true then only hidden articles. If set to false then only non-hidden articles.</param>
        /// <returns>returns a list of ProviderArticles based on the passed in paramters.</returns>
        static public List<ProviderArticle> LoadBy(long memberId, bool? isPublished, bool? isHidden)
        {
            return DbCtx.Instance.Articles.Where(anArticle => anArticle.MemberId == memberId &&
                                                                  (isPublished == null || isPublished == anArticle.IsPublished) &&
                                                                  (isHidden == null || isHidden == anArticle.IsHidden))
                                              .OrderByDescending(article => article.EditDate)
                                              .ToList()
                                              .ConvertAll(_converterEntityToProvider);
        }

        static public List<ProviderArticle> LoadBy(IProviderArticleFilter filter)
        {
            int m = (filter.Page - 1);
            if (m < 0) m = 0;
            int skip = filter.Rows * m;
            IQueryable<Article> query = DbCtx.Instance.Articles;
            query = ArticleFilter(filter, query);
            query = ArticleSort(filter, query);
            return query.Skip(skip)
                    .Take(filter.Rows)
                    .ToList()
                    .ConvertAll(_converterEntityToProvider);
        }

        static public int Count()
        {
            return DbCtx.Instance.Articles.Count();
        }

        static public int Count(IProviderArticleFilter filter)
        {
            IQueryable<Article> query = DbCtx.Instance.Articles;
            query = ArticleFilter(filter, query);
            return query.Count();
        }

        static protected IQueryable<Article> ArticleSort(IProviderArticleFilter filter, IQueryable<Article> query)
        {
            // Sort grid data.  Sord is sort order, Sidx is the index to sort on
            if (filter.Sord == "desc")
            {
                if (filter.Sidx == "CountFlags")
                {
                    // TODO: Rework the CountFlag logics to be more useful, right now it's just a lowerbound
                    query = query.OrderByDescending(anArticle => anArticle.ArticleVotes
                                            .Where(vote => vote.IsFlag)
                                            .Count());
                }
                else
                {
                    // Sort by date if we don't know what this was
                    query = query.OrderByDescending(anArticle => anArticle.EditDate);
                }
            }
            else if (filter.Sord == "asc")
            {
                if (filter.Sidx == "CountFlags")
                {
                    query = query.OrderBy(anArticle => anArticle.ArticleVotes
                                            .Where(vote => vote.IsFlag)
                                            .Count());
                }
                else
                {
                    // Sort by date if we don't know what this was
                    query = query.OrderBy(anArticle => anArticle.EditDate);
                }
            }

            return query;
        }

        static protected IQueryable<Article> ArticleFilter(IProviderArticleFilter filter, IQueryable<Article> query)
        {
            return query.Where(anArticle => (filter.Id == null || anArticle.Id == filter.Id) &&
                            (filter.Title == null || anArticle.Title.Contains(filter.Title)) &&
                            (filter.IsHidden == null || anArticle.IsHidden == filter.IsHidden) &&
                            (filter.IsPublished == null || anArticle.IsPublished == filter.IsPublished) &&
                            (filter.IgnoreFlags == null || anArticle.IgnoreFlags == filter.IgnoreFlags) &&
                            (filter.MemberId == null || anArticle.MemberId == filter.MemberId) &&
                            (filter.CountFlags == null || anArticle.ArticleVotes.Where(vote => vote.IsFlag).Count() >= filter.CountFlags)
                        );
        }

        static public DateTime GetSystemCreateDateByArticleId(long articleId)
        {
            return DbCtx.Instance.Articles
                                      .Where(anArticle => anArticle.Id == articleId)
                                      .Select(anArticle => anArticle.SystemCreateDate)
                                      .FirstOrDefault();
        }

        static public Dictionary<long, string> GetNewestIdTitle(int max)
        {
            return DbCtx.Instance.Articles
                                      .Where(anArticle => !anArticle.IsHidden && anArticle.IsPublished)
                                      .OrderByDescending(article => article.SystemCreateDate)
                                      .Take(max)
                                      .Select(anArticle => new { anArticle.Id, anArticle.Title })
                                      .ToDictionary(pair => pair.Id, pair => pair.Title);
        }



        static public List<long> GetAllArticleId()
        {
            return DbCtx.Instance.Articles
                                    .Select(anArticle => anArticle.Id)
                                    .ToList();
        }

        static public List<long> GetArticleIdByMember(long memberId)
        {
            return DbCtx.Instance.Articles
                                    .Where(anArticle => anArticle.MemberId == memberId)
                                    .Select(anArticle => anArticle.Id)
                                    .ToList();
        }

        static public List<long> GetArticleIdByAltCategory(long altCategoryId)
        {
            return DbCtx.Instance.Articles
                                    .Where(anArticle => anArticle.AlternateCategoryIds.Any(altCat => altCat.Id == altCategoryId))
                                    .Select(anArticle => anArticle.Id)
                                    .ToList();
        }

        /// <summary>
        /// Indicates if an object with a given Id exists
        /// </summary>
        /// <param name="id">Id of the object whose existence we wish to check</param>
        /// <returns></returns>
        static public bool Exists(long id)
        {
            return id >= 0 && DbCtx.Instance.Articles.Where(anArticle => anArticle.Id == id).Count() > 0;
        }

        static public List<ProviderArticle> LoadByGroupId(long id)
        {
            return DbCtx.Instance.Groups
                .Where(aGroup => aGroup.Id == id)
                .SelectMany(aGroup => aGroup.Memberships)
                .Select(aMembership => aMembership.Member)
                .SelectMany(aMember => aMember.PostedArticles)
                .ToList()
                .ConvertAll(_converterEntityToProvider);
        }

        public enum ArticleState
        {
            delete = -3,
            hidden,
            flagged,
            draft,
            publish
        }

        public enum TextType
        {
            raw = 0,
            parsed
        }
    #endregion
    }
}